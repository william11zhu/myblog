import{_ as o,r as l,c as i,a as t,d as n,b as s,w as e,e as p,o as c}from"./app-aMviFWVd.js";const r={},u=p(`<h3 id="快速幂" tabindex="-1"><a class="header-anchor" href="#快速幂"><span>快速幂</span></a></h3><p>autor: iamtwz, billchenchina, CBW2007, CCXXXI, chinggg, Enter-tainer, eyedeng, FFjet, gaojude, Great-designer, H-J-Granger, Henry-ZHR, hsfzLZH1, Ir1d, kenlig, Konano, ksyx, luoguyuntianming, Marcythm, Menci, NachtgeistW, ouuan, Peanut-Tang, qwqAutomaton, sshwy, StudyingFather, Tiphereth-A, TrisolarisHD, TRSWNCA, Xeonacid, Yuuko10032, Zhangjiacheng2006, Zhoier, Hszzzx, shenshuaijie, kfy666</p><h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义</span></a></h2><p>快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个在 $\\Theta(\\log n)$ 的时间内计算 $a^n$ 的小技巧，而暴力的计算需要 $\\Theta(n)$ 的时间。</p><p>这个技巧也常常用在非计算的场景，因为它可以应用在任何具有结合律的运算中。其中显然的是它可以应用于模意义下取幂、矩阵幂等运算，我们接下来会讨论。</p><h2 id="解释" tabindex="-1"><a class="header-anchor" href="#解释"><span>解释</span></a></h2><p>计算 $a$ 的 $n$ 次方表示将 $n$ 个 $a$ 乘在一起：$a^{n} = \\underbrace{a \\times a \\cdots \\times a}_{n\\text{ 个 a}}$。然而当 $a,n$ 太大的时侯，这种方法就不太适用了。不过我们知道：$a^{b+c} = a^b \\cdot a^c,,,a^{2b} = a^b \\cdot a^b = (a^b)^2$。二进制取幂的想法是，我们将取幂的任务按照指数的 <strong>二进制表示</strong> 来分割成更小的任务。</p><h2 id="过程" tabindex="-1"><a class="header-anchor" href="#过程"><span>过程</span></a></h2><h3 id="迭代版本" tabindex="-1"><a class="header-anchor" href="#迭代版本"><span>迭代版本</span></a></h3><p>首先我们将 $n$ 表示为 2 进制，举一个例子：</p><p>$$ 3^{13} = 3^{(1101)_2} = 3^8 \\cdot 3^4 \\cdot 3^1 $$</p><p>因为 $n$ 有 $\\lfloor \\log_2 n \\rfloor + 1$ 个二进制位，因此当我们知道了 $a^1, a^2, a^4, a^8, \\dots, a^{2^{\\lfloor \\log_2 n \\rfloor}}$ 后，我们只用计算 $\\Theta(\\log n)$ 次乘法就可以计算出 $a^n$。</p><p>于是我们只需要知道一个快速的方法来计算上述 3 的 $2^k$ 次幂的序列。这个问题很简单，因为序列中（除第一个）任意一个元素就是其前一个元素的平方。举一个例子：</p><p>$$ \\begin{align} 3^1 &amp;= 3 \\ 3^2 &amp;= \\left(3^1\\right)^2 = 3^2 = 9 \\ 3^4 &amp;= \\left(3^2\\right)^2 = 9^2 = 81 \\ 3^8 &amp;= \\left(3^4\\right)^2 = 81^2 = 6561 \\end{align} $$</p><p>因此为了计算 $3^{13}$，我们只需要将对应二进制位为 1 的整系数幂乘起来就行了：</p><p>$$ 3^{13} = 6561 \\cdot 81 \\cdot 3 = 1594323 $$</p><p>将上述过程说得形式化一些，如果把 $n$ 写作二进制为 $(n_tn_{t-1}\\cdots n_1n_0)_2$，那么有：</p><p>$$ n = n_t2^t + n_{t-1}2^{t-1} + n_{t-2}2^{t-2} + \\cdots + n_12^1 + n_02^0 $$</p><p>其中 $n_i\\in{0,1}$。那么就有</p><p>$$ \\begin{aligned} a^n &amp; = (a^{n_t 2^t + \\cdots + n_0 2^0})\\\\ &amp; = a^{n_0 2^0} \\times a^{n_1 2^1}\\times \\cdots \\times a^{n_t2^t} \\end{aligned} $$</p><p>根据上式我们发现，原问题被我们转化成了形式相同的子问题的乘积，并且我们可以在常数时间内从 $2^i$ 项推出 $2^{i+1}$ 项。</p><p>这个算法的复杂度是 $\\Theta(\\log n)$ 的，我们计算了 $\\Theta(\\log n)$ 个 $2^k$ 次幂的数，然后花费 $\\Theta(\\log n)$ 的时间选择二进制为 1 对应的幂来相乘。</p><h3 id="递归版本" tabindex="-1"><a class="header-anchor" href="#递归版本"><span>递归版本</span></a></h3><p>上述迭代版本中，由于 $2^{i+1}$ 项依赖于 $2^i$，使得其转换为递归版本比较困难（一方面需要返回一个额外的 $a^{2^i}$，对函数来说无法实现一个只返回计算结果的接口；另一方面则是必须从低位往高位计算，即从高位往低位调用，这也造成了递归实现的困扰），下面则提供递归版本的思路。</p><p>给定形式 $n_{t\\dots i} = (n_tn_{t-1}\\cdots n_i)<em>2$，即 $n</em>{t\\dots i}$ 表示将 $n$ 的前 $t - i + 1$ 位二进制位当作一个二进制数，则有如下变换：</p><p>$$ \\begin{aligned} n &amp;= n_{t\\dots 0} \\ &amp;= 2\\times n_{t\\dots 1} + n_0\\ &amp;= 2\\times (2\\times n_{t\\dots 2} + n_1) + n_0 \\ &amp;\\cdots \\end{aligned} $$</p><p>那么有：</p><p>$$ \\begin{aligned} a^n &amp;= a^{n_{t\\dots 0}} \\ &amp;= a^{2\\times n_{t\\dots 1} + n_0} = \\left(a^{n_{t\\dots 1}}\\right)^2 a^{n_0} \\ &amp;= \\left(a^{2\\times n_{t\\dots 2} + n_1}\\right)^2 a^{n_0} = \\left(\\left(a^{n_{t\\dots 2}}\\right)^2 a^{n_1}\\right)^2 a^{n_0} \\ &amp;\\cdots \\end{aligned} $$</p><p>如上所述，在递归时，对于不同的递归深度是相同的处理：$a^{n_{t\\dots i}} = (a^{n_{t\\dots (i+1)}})^2a^{n_i}$，即将当前递归的二进制数拆成两部分：最低位在递归出来时乘上去，其余部分则变成新的二进制数递归进入更深一层作相同的处理。</p><p>可以观察到，每递归深入一层则二进制位减少一位，所以该算法的时间复杂度也为 $\\Theta(\\log n)$。</p><h2 id="实现" tabindex="-1"><a class="header-anchor" href="#实现"><span>实现</span></a></h2><p>首先我们可以直接按照上述递归方法实现：</p><p>=== &quot;C++&quot;</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="line"><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">binpow</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> a<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">long</span> <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token function">binpow</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">return</span> res <span class="token operator">*</span> res <span class="token operator">*</span> a<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">else</span></span>
<span class="line"><span class="token keyword">return</span> res <span class="token operator">*</span> res<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>=== &quot;Python&quot;</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py" data-title="py"><pre class="language-python"><code><span class="line"><span class="token keyword">def</span> <span class="token function">binpow</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line"><span class="token keyword">if</span> b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span></span>
<span class="line"><span class="token keyword">return</span> <span class="token number">1</span></span>
<span class="line">res <span class="token operator">=</span> binpow<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span></span>
<span class="line"><span class="token keyword">return</span> res <span class="token operator">*</span> res <span class="token operator">*</span> a</span>
<span class="line"><span class="token keyword">else</span><span class="token punctuation">:</span></span>
<span class="line"><span class="token keyword">return</span> res <span class="token operator">*</span> res</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二种实现方法是非递归式的。它在循环的过程中将二进制位为 1 时对应的幂累乘到答案中。尽管两者的理论复杂度是相同的，但第二种在实践过程中的速度是比第一种更快的，因为递归会花费一定的开销。</p><p>=== &quot;C++&quot;</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="line"><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">binpow</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> a<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token keyword">long</span> <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">while</span> <span class="token punctuation">(</span>b <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> res <span class="token operator">*</span> a<span class="token punctuation">;</span></span>
<span class="line">a <span class="token operator">=</span> a <span class="token operator">*</span> a<span class="token punctuation">;</span></span>
<span class="line">b <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">return</span> res<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>=== &quot;Python&quot;</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py" data-title="py"><pre class="language-python"><code><span class="line"><span class="token keyword">def</span> <span class="token function">binpow</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">res <span class="token operator">=</span> <span class="token number">1</span></span>
<span class="line"><span class="token keyword">while</span> b <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">res <span class="token operator">=</span> res <span class="token operator">*</span> a</span>
<span class="line">a <span class="token operator">=</span> a <span class="token operator">*</span> a</span>
<span class="line">b <span class="token operator">&gt;&gt;</span><span class="token operator">=</span> <span class="token number">1</span></span>
<span class="line"><span class="token keyword">return</span> res</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>模板：<a href="https://www.luogu.com.cn/problem/P1226" target="_blank" rel="noopener noreferrer">Luogu P1226</a></p><h2 id="应用" tabindex="-1"><a class="header-anchor" href="#应用"><span>应用</span></a></h2><h3 id="模意义下取幂" tabindex="-1"><a class="header-anchor" href="#模意义下取幂"><span>模意义下取幂</span></a></h3><p>???+ note &quot;问题描述&quot; 计算 $x^n\\bmod m$。</p><p>这是一个非常常见的应用，例如它可以用于计算模意义下的乘法逆元。</p><p>既然我们知道取模的运算不会干涉乘法运算，因此我们只需要在计算的过程中取模即可。</p><p>=== &quot;C++&quot;</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="line"><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">binpow</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> a<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> b<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">a <span class="token operator">%=</span> m<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">long</span> <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">while</span> <span class="token punctuation">(</span>b <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> res <span class="token operator">*</span> a <span class="token operator">%</span> m<span class="token punctuation">;</span></span>
<span class="line">a <span class="token operator">=</span> a <span class="token operator">*</span> a <span class="token operator">%</span> m<span class="token punctuation">;</span></span>
<span class="line">b <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">return</span> res<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>=== &quot;Python&quot;</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py" data-title="py"><pre class="language-python"><code><span class="line"><span class="token keyword">def</span> <span class="token function">binpow</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">a <span class="token operator">=</span> a <span class="token operator">%</span> m</span>
<span class="line">res <span class="token operator">=</span> <span class="token number">1</span></span>
<span class="line"><span class="token keyword">while</span> b <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">res <span class="token operator">=</span> res <span class="token operator">*</span> a <span class="token operator">%</span> m</span>
<span class="line">a <span class="token operator">=</span> a <span class="token operator">*</span> a <span class="token operator">%</span> m</span>
<span class="line">b <span class="token operator">&gt;&gt;</span><span class="token operator">=</span> <span class="token number">1</span></span>
<span class="line"><span class="token keyword">return</span> res</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：根据费马小定理，如果 $m$ 是一个质数，我们可以计算 $x^{n\\bmod (m-1)}$ 来加速算法过程。</p><h3 id="计算斐波那契数" tabindex="-1"><a class="header-anchor" href="#计算斐波那契数"><span>计算斐波那契数</span></a></h3><p>???+ note &quot;问题描述&quot; 计算斐波那契数列第 $n$ 项 $F_n$。</p>`,54),d=p('<h3 id="多次置换" tabindex="-1"><a class="header-anchor" href="#多次置换"><span>多次置换</span></a></h3><p>???+ note &quot;问题描述&quot; 给你一个长度为 $n$ 的序列和一个置换，把这个序列置换 $k$ 次。</p><p>简单地把这个置换取 $k$ 次幂，然后把它应用到序列 $n$ 上即可。时间复杂度是 $O(n \\log k)$ 的。</p><p>注意：给这个置换建图，然后在每一个环上分别做 $k$ 次幂（事实上做一下 $k$ 对环长取模的运算即可）可以取得更高效的算法，达到 $O(n)$ 的复杂度。</p><h3 id="加速几何中对点集的操作" tabindex="-1"><a class="header-anchor" href="#加速几何中对点集的操作"><span>加速几何中对点集的操作</span></a></h3><h4 id="引入" tabindex="-1"><a class="header-anchor" href="#引入"><span>引入</span></a></h4><blockquote><p>三维空间中，$n$ 个点 $p_i$，要求将 $m$ 个操作都应用于这些点。包含 3 种操作：</p><ol><li>沿某个向量移动点的位置（Shift）。</li><li>按比例缩放这个点的坐标（Scale）。</li><li>绕某个坐标轴旋转（Rotate）。</li></ol><p>还有一个特殊的操作，就是将一个操作序列重复 $k$ 次（Loop），这个序列中也可能有 Loop 操作（Loop 操作可以嵌套）。现在要求你在低于 $O(n \\cdot \\textit{length})$ 的时间内将这些变换应用到这个 $n$ 个点，其中 $\\textit{length}$ 表示把所有的 Loop 操作展开后的操作序列的长度。</p></blockquote><h4 id="解释-1" tabindex="-1"><a class="header-anchor" href="#解释-1"><span>解释</span></a></h4><p>让我们来观察一下这三种操作对坐标的影响：</p><ol><li>Shift 操作：将每一维的坐标分别加上一个常量；</li><li>Scale 操作：把每一维坐标分别乘上一个常量；</li><li>Rotate 操作：这个有点复杂，我们不打算深入探究，不过我们仍然可以使用一个线性组合来表示新的坐标。</li></ol><p>可以看到，每一个变换可以被表示为对坐标的线性运算，因此，一个变换可以用一个 $4\\times 4$ 的矩阵来表示：</p><p>$$ \\begin{bmatrix} a_{11} &amp; a_ {12} &amp; a_ {13} &amp; a_ {14} \\ a_{21} &amp; a_ {22} &amp; a_ {23} &amp; a_ {24} \\ a_{31} &amp; a_ {32} &amp; a_ {33} &amp; a_ {34} \\ a_{41} &amp; a_ {42} &amp; a_ {43} &amp; a_ {44} \\ \\end{bmatrix} $$</p><p>使用这个矩阵就可以将一个坐标（向量）进行变换，得到新的坐标（向量）：</p><p>$$ \\begin{bmatrix} a_{11} &amp; a_ {12} &amp; a_ {13} &amp; a_ {14} \\ a_{21} &amp; a_ {22} &amp; a_ {23} &amp; a_ {24} \\ a_{31} &amp; a_ {32} &amp; a_ {33} &amp; a_ {34} \\ a_{41} &amp; a_ {42} &amp; a_ {43} &amp; a_ {44} \\ \\end{bmatrix}\\cdot \\begin{bmatrix} x \\ y \\ z \\ 1 \\end{bmatrix} = \\begin{bmatrix} x&#39; \\ y&#39; \\ z&#39; \\ 1 \\end{bmatrix} $$</p><p>你可能会问，为什么一个三维坐标会多一个 1 出来？原因在于，如果没有这个多出来的 1，我们没法使用矩阵的线性变换来描述 Shift 操作。</p><h4 id="过程-1" tabindex="-1"><a class="header-anchor" href="#过程-1"><span>过程</span></a></h4><p>接下来举一些简单的例子来说明我们的思路：</p><ol><li><p>Shift 操作：让 $x$ 坐标方向的位移为 $5$，$y$ 坐标的位移为 $7$，$z$ 坐标的位移为 $9$：</p><p>$$ \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 5 \\ 0 &amp; 1 &amp; 0 &amp; 7 \\ 0 &amp; 0 &amp; 1 &amp; 9 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ \\end{bmatrix} $$</p></li><li><p>Scale 操作：把 $x$ 坐标拉伸 10 倍，$y,z$ 坐标拉伸 5 倍：</p><p>$$ \\begin{bmatrix} 10 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 5 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 5 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ \\end{bmatrix} $$</p></li><li><p>Rotate 操作：绕 $x$ 轴旋转 $\\theta$ 弧度，遵循右手定则（逆时针方向）</p><p>$$ \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; \\cos \\theta &amp; \\sin \\theta &amp; 0 \\ 0 &amp; -\\sin \\theta &amp; \\cos \\theta &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ \\end{bmatrix} $$</p></li></ol><p>现在，每一种操作都被表示为了一个矩阵，变换序列可以用矩阵的乘积来表示，而一个 Loop 操作相当于取一个矩阵的 k 次幂。这样可以用 $O(m \\log k)$ 计算出整个变换序列最终形成的矩阵。最后将它应用到 $n$ 个点上，总复杂度 $O(n + m \\log k)$。</p><h3 id="定长路径计数" tabindex="-1"><a class="header-anchor" href="#定长路径计数"><span>定长路径计数</span></a></h3><p>???+ note &quot;问题描述&quot; 给一个有向图（边权为 1），求任意两点 $u,v$ 间从 $u$ 到 $v$，长度为 $k$ 的路径的条数。</p>',21),k=p(`<h3 id="模意义下大整数乘法" tabindex="-1"><a class="header-anchor" href="#模意义下大整数乘法"><span>模意义下大整数乘法</span></a></h3><blockquote><p>计算 $a\\times b\\bmod m,,,a,b\\le m\\le 10^{18}$。</p></blockquote><p>与二进制取幂的思想一样，这次我们将其中的一个乘数表示为若干个 2 的整数次幂的和的形式。因为在对一个数做乘 2 并取模的运算的时侯，我们可以转化为加减操作防止溢出。这样仍可以在 $O (\\log_2 m)$ 的时内解决问题。递归方法如下：</p><p>$$ a \\cdot b = \\begin{cases} 0 &amp;\\text{if }a = 0 \\\\ 2 \\cdot \\frac{a}{2} \\cdot b &amp;\\text{if }a &gt; 0 \\text{ and }a \\text{ even} \\\\ 2 \\cdot \\frac{a-1}{2} \\cdot b + b &amp;\\text{if }a &gt; 0 \\text{ and }a \\text{ odd} \\end{cases} $$</p><h4 id="快速乘" tabindex="-1"><a class="header-anchor" href="#快速乘"><span>快速乘</span></a></h4><p>但是 $O(\\log_2 m)$ 的「龟速乘」还是太慢了，这在很多对常数要求比较高的算法比如 Miller_Rabin 和 Pollard-Rho 中，就显得不够用了。所以我们要介绍一种可以处理模数在 <code>long long</code> 范围内、不需要使用黑科技 <code>__int128</code> 的、复杂度为 $O(1)$ 的「快速乘」。</p><p>我们发现：</p><p>$$ a\\times b\\bmod m=a\\times b-\\left\\lfloor \\dfrac{ab}m \\right\\rfloor\\times m $$</p><p>我们巧妙运用 <code>unsigned long long</code> 的自然溢出：</p><p>$$ a\\times b\\bmod m=a\\times b-\\left\\lfloor \\dfrac{ab}m \\right\\rfloor\\times m=\\left(a\\times b-\\left\\lfloor \\dfrac{ab}m \\right\\rfloor\\times m\\right)\\bmod 2^{64} $$</p><p>于是在算出 $\\left\\lfloor\\dfrac{ab}m\\right\\rfloor$ 后，两边的乘法和中间的减法部分都可以使用 <code>unsigned long long</code> 直接计算，现在我们只需要解决如何计算 $\\left\\lfloor\\dfrac {ab}m\\right\\rfloor$。</p><p>我们考虑先使用 <code>long double</code> 算出 $\\dfrac am$ 再乘上 $b$。</p><p>既然使用了 <code>long double</code>，就无疑会有精度误差。极端情况就是第一个有效数字（二进制下）在小数点后一位。在 <code>x86-64</code> 机器下，<code>long double</code> 将被解释成 $80$ 位拓展小数（即符号为 $1$ 位，指数为 $15$ 位，尾数为 $64$ 位），所以 <code>long double</code> 最多能精确表示的有效位数为 $64$[^note1]。所以 $\\dfrac am$ 最差从第 $65$ 位开始出错，误差范围为 $\\left(-2^{-64},2^{64}\\right)$。乘上 $b$ 这个 $64$ 位整数，误差范围为 $(-0.5,0.5)$，再加上 $0.5$ 误差范围为 $(0,1)$，取整后误差范围位 \${0,1}$。于是乘上 $-m$ 后，误差范围变成 \${0,-m}$，我们需要判断这两种情况。</p><p>因为 $m$ 在 <code>long long</code> 范围内，所以如果计算结果 $r$ 在 $[0,m)$ 时，直接返回 $r$，否则返回 $r+m$，当然你也可以直接返回 $(r+m)\\bmod m$。</p><p>代码实现如下：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="line"><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">binmul</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> a<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> b<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> c <span class="token operator">=</span></span>
<span class="line">      <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>a <span class="token operator">*</span> b <span class="token operator">-</span></span>
<span class="line">      <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">double</span><span class="token punctuation">)</span>a <span class="token operator">/</span> m <span class="token operator">*</span> b <span class="token operator">+</span> <span class="token number">0.5L</span><span class="token punctuation">)</span> <span class="token operator">*</span> m<span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> c<span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">return</span> c <span class="token operator">+</span> m<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="高精度快速幂" tabindex="-1"><a class="header-anchor" href="#高精度快速幂"><span>高精度快速幂</span></a></h3>`,17),m=p(`<p>???+ note &quot; 例题【NOIP2003 普及组改编·麦森数】（<a href="https://www.luogu.com.cn/problem/P1045" target="_blank" rel="noopener noreferrer">原题在此</a>）&quot; 题目大意：从文件中输入 $P$（$1000 &lt; P &lt; 3100000$），计算 $2^P−1$ 的最后 100 位数字（用十进制高精度数表示），不足 100 位时高位补 0。</p><p>代码实现如下：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="line"><span class="token operator">--</span><span class="token number">8</span><span class="token operator">&lt;</span><span class="token operator">--</span> <span class="token string">&quot;docs/math/code/quick-pow/quick-pow_1.cpp&quot;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="同一底数与同一模数的预处理快速幂" tabindex="-1"><a class="header-anchor" href="#同一底数与同一模数的预处理快速幂"><span>同一底数与同一模数的预处理快速幂</span></a></h3><p>在同一底数与同一模数的条件下，可以利用分块思想，用一定的时间（一般是 $O(\\sqrt n)$）预处理后用 $O(1)$ 的时间回答一次幂询问。</p><h4 id="过程-2" tabindex="-1"><a class="header-anchor" href="#过程-2"><span>过程</span></a></h4><ol><li>选定一个数 $s$，预处理出 $a^0$ 到 $a^s$ 与 $a^{0\\cdot s}$ 到 $a^{\\lceil\\frac ps\\rceil\\cdot s}$ 的值并存在一个（或两个）数组里；</li><li>对于每一次询问 $a^b\\bmod p$，将 $b$ 拆分成 $\\left\\lfloor\\dfrac bs\\right\\rfloor\\cdot s+b\\bmod s$，则 $a^b=a^{\\lfloor\\frac bs\\rfloor\\cdot s}\\times a^{b\\bmod s}$，可以 $O(1)$ 求出答案。</li></ol><p>关于这个数 $s$ 的选择，我们一般选择 $\\sqrt p$ 或者一个大小适当的 $2$ 的次幂（选择 $\\sqrt p$ 可以使预处理较优，选择 $2$ 的次幂可以使用位运算优化/简化计算）。</p><p>??? note &quot;参考代码&quot;</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="line"><span class="token keyword">int</span> pow1<span class="token punctuation">[</span><span class="token number">65536</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pow2<span class="token punctuation">[</span><span class="token number">65536</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">void</span> <span class="token function">preproc</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> mod<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      pow1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> pow2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">65536</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> pow1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1LL</span> <span class="token operator">*</span> pow1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> a <span class="token operator">%</span> mod<span class="token punctuation">;</span></span>
<span class="line">      <span class="token keyword">int</span> pow65536 <span class="token operator">=</span> <span class="token number">1LL</span> <span class="token operator">*</span> pow1<span class="token punctuation">[</span><span class="token number">65535</span><span class="token punctuation">]</span> <span class="token operator">*</span> a <span class="token operator">%</span> mod<span class="token punctuation">;</span></span>
<span class="line">      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">65536</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> pow2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1LL</span> <span class="token operator">*</span> pow2<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> pow65536 <span class="token operator">%</span> mod<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    </span>
<span class="line">    <span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">int</span> pows<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">1LL</span> <span class="token operator">*</span> pow1<span class="token punctuation">[</span>pows <span class="token operator">&amp;</span> <span class="token number">65535</span><span class="token punctuation">]</span> <span class="token operator">*</span> pow2<span class="token punctuation">[</span>pows <span class="token operator">&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="习题" tabindex="-1"><a class="header-anchor" href="#习题"><span>习题</span></a></h2><ul><li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=24&amp;page=show_problem&amp;problem=3671" target="_blank" rel="noopener noreferrer">UVa 1230 - MODEX</a></li><li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=24&amp;page=show_problem&amp;problem=310" target="_blank" rel="noopener noreferrer">UVa 374 - Big Mod</a></li><li><a href="https://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=1970" target="_blank" rel="noopener noreferrer">UVa 11029 - Leading and Trailing</a></li><li><a href="http://codeforces.com/problemset/problem/630/I" target="_blank" rel="noopener noreferrer">Codeforces - Parking Lot</a></li><li><a href="http://www.spoj.com/problems/LASTDIG/" target="_blank" rel="noopener noreferrer">SPOJ - The last digit</a></li><li><a href="http://www.spoj.com/problems/LOCKER/" target="_blank" rel="noopener noreferrer">SPOJ - Locker</a></li><li><a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1723" target="_blank" rel="noopener noreferrer">LA - 3722 Jewel-eating Monsters</a></li><li><a href="http://www.spoj.com/problems/ZSUM/" target="_blank" rel="noopener noreferrer">SPOJ - Just add it</a></li></ul><p><strong>本页面部分内容译自博文 <a href="http://e-maxx.ru/algo/binary_pow" target="_blank" rel="noopener noreferrer">Бинарное возведение в степень</a> 与其英文翻译版 <a href="https://cp-algorithms.com/algebra/binary-exp.html" target="_blank" rel="noopener noreferrer">Binary Exponentiation</a>。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。</strong></p><h2 id="参考资料与注释" tabindex="-1"><a class="header-anchor" href="#参考资料与注释"><span>参考资料与注释</span></a></h2><ul><li>参见 <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" target="_blank" rel="noopener noreferrer">C 语言小数表示法 - 维基百科</a></li><li>参见 <a href="https://blog.csdn.net/m0_52072919/article/details/116400820" target="_blank" rel="noopener noreferrer">快速幂算法 超详细教程</a></li></ul>`,15);function $(b,h){const a=l("RouteLink");return c(),i("div",null,[u,t("p",null,[n("根据斐波那契数列的递推式 $F_n = F_{n-1} + F_{n-2}$，我们可以构建一个 $2\\times 2$ 的矩阵来表示从 $F_i,F_{i+1}$ 到 $F_{i+1},F_{i+2}$ 的变换。于是在计算这个矩阵的 $n$ 次幂的时侯，我们使用快速幂的思想，可以在 $\\Theta(\\log n)$ 的时间内计算出结果。对于更多的细节参见 "),s(a,{to:"/algorithm/math/combinatorics/fibonacci.html"},{default:e(()=>[n("斐波那契数列")]),_:1}),n("，矩阵快速幂的实现参见 "),s(a,{to:"/algorithm/math/linear-algebra/matrix.html#%E7%9F%A9%E9%98%B5%E5%8A%A0%E9%80%9F%E9%80%92%E6%8E%A8"},{default:e(()=>[n("矩阵加速递推")]),_:1}),n(" 中的实现。")]),d,t("p",null,[n("我们把该图的邻接矩阵 M 取 k 次幂，那么 $M_{i,j}$ 就表示从 $i$ 到 $j$ 长度为 $k$ 的路径的数目。该算法的复杂度是 $O(n^3 \\log k)$。有关该算法的细节请参见 "),s(a,{to:"/algorithm/math/linear-algebra/matrix.html"},{default:e(()=>[n("矩阵")]),_:1}),n(" 页面。")]),k,t("p",null,[n('??? note "前置技能" 请先学习 '),s(a,{to:"/algorithm/math/bignum.html"},{default:e(()=>[n("高精度")]),_:1})]),m])}const v=o(r,[["render",$],["__file","binary-exponentiation.html.vue"]]),f=JSON.parse('{"path":"/algorithm/math/binary-exponentiation.html","title":"快速幂","lang":"zh-CN","frontmatter":{"lang":"zh-CN","title":"快速幂"},"headers":[{"level":3,"title":"快速幂","slug":"快速幂","link":"#快速幂","children":[]},{"level":2,"title":"定义","slug":"定义","link":"#定义","children":[]},{"level":2,"title":"解释","slug":"解释","link":"#解释","children":[]},{"level":2,"title":"过程","slug":"过程","link":"#过程","children":[{"level":3,"title":"迭代版本","slug":"迭代版本","link":"#迭代版本","children":[]},{"level":3,"title":"递归版本","slug":"递归版本","link":"#递归版本","children":[]}]},{"level":2,"title":"实现","slug":"实现","link":"#实现","children":[]},{"level":2,"title":"应用","slug":"应用","link":"#应用","children":[{"level":3,"title":"模意义下取幂","slug":"模意义下取幂","link":"#模意义下取幂","children":[]},{"level":3,"title":"计算斐波那契数","slug":"计算斐波那契数","link":"#计算斐波那契数","children":[]},{"level":3,"title":"多次置换","slug":"多次置换","link":"#多次置换","children":[]},{"level":3,"title":"加速几何中对点集的操作","slug":"加速几何中对点集的操作","link":"#加速几何中对点集的操作","children":[]},{"level":3,"title":"定长路径计数","slug":"定长路径计数","link":"#定长路径计数","children":[]},{"level":3,"title":"模意义下大整数乘法","slug":"模意义下大整数乘法","link":"#模意义下大整数乘法","children":[]},{"level":3,"title":"高精度快速幂","slug":"高精度快速幂","link":"#高精度快速幂","children":[]},{"level":3,"title":"同一底数与同一模数的预处理快速幂","slug":"同一底数与同一模数的预处理快速幂","link":"#同一底数与同一模数的预处理快速幂","children":[]}]},{"level":2,"title":"习题","slug":"习题","link":"#习题","children":[]},{"level":2,"title":"参考资料与注释","slug":"参考资料与注释","link":"#参考资料与注释","children":[]}],"git":{"updatedTime":1720611675000,"contributors":[{"name":"zhujj","email":"william11zhu@qq.com","commits":1}]},"filePathRelative":"algorithm/math/binary-exponentiation.md"}');export{v as comp,f as data};
